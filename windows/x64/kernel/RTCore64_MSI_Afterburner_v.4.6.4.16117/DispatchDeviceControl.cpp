__int64 __fastcall DispatchDeviceControl(__int64 a1, IRP *status)
{
    _IO_STACK_LOCATION *CurrentStackLocation; // rax
    _IRP *MasterIrp;                          // rbx
    unsigned int Options;                     // edx
    unsigned int v6;                          // er9
    unsigned int IOCTL_Code;                  // eax
    int v8;                                   // eax
    int v9;                                   // eax
    int v10;                                  // eax
    unsigned __int32 v11;                     // eax
    unsigned __int16 v12;                     // ax
    char v13;                                 // al
    int v14;                                  // eax
    int v15;                                  // eax
    ULONG Length;                             // ecx
    ULONG Offset;                             // edx
    ULONG Flags;                              // ecx
    PMDL v19;                                 // r8
    __int64 v20;                              // r10
    LONG v21;                                 // edx
    __int64 v22;                              // r9
    int v23;                                  // edx
    int v24;                                  // edx
    PMDL v25;                                 // r8
    __int64 v26;                              // r10
    LONG IrpCount;                            // edx
    __int64 v28;                              // r9
    int v29;                                  // edx
    int v30;                                  // edx
    PMDL MdlAddress;                          // rcx
    __int64 Blink_high;                       // rdx
    NTSTATUS v33;                             // eax
    unsigned int v34;                         // ecx
    unsigned int v35;                         // ecx
    unsigned int v36;                         // ebx
    unsigned __int64 v38;                     // [rsp+50h] [rbp+18h]

    status->IoStatus.Status = 0;
    status->IoStatus.Information = 0i64;
    CurrentStackLocation = status->Tail.Overlay.CurrentStackLocation;
    MasterIrp = status->AssociatedIrp.MasterIrp;
    Options = CurrentStackLocation->Parameters.Create.Options;
    v6 = CurrentStackLocation->Parameters.Read.Length;
    if (CurrentStackLocation->MajorFunction == 14) // UserBufferIn_Size
    {
        IOCTL_Code = CurrentStackLocation->Parameters.Read.ByteOffset.LowPart;
        if (IOCTL_Code > 0x8000202C)
        {
            switch (IOCTL_Code)
            {
            case 0x80002030:
                if (Options == 12)
                {
                    v35 = *(_DWORD *)&MasterIrp->Type;
                    if ((unsigned int)(*(_DWORD *)&MasterIrp->Type - 372) <= 2 || v35 + 1073741696 <= 4)
                    {
                        status->IoStatus.Status = 0xC000000D;
                    }
                    else
                    {
                        v38 = __readmsr(v35);
                        *(_DWORD *)(&MasterIrp->Size + 1) = HIDWORD(v38);
                        LODWORD(MasterIrp->MdlAddress) = v38;
                        status->IoStatus.Status = 0;
                        status->IoStatus.Information = 12i64;
                    }
                }
                else
                {
                    status->IoStatus.Status = 0xC000000D;
                }
                break;
            case 0x80002034:
                if (Options == 12)
                {
                    v34 = *(_DWORD *)&MasterIrp->Type;
                    if ((unsigned int)(*(_DWORD *)&MasterIrp->Type - 372) <= 2 || v34 + 1073741696 <= 4)
                    {
                        status->IoStatus.Status = -1073741811;
                    }
                    else
                    {
                        __writemsr(v34, __PAIR64__(*(_DWORD *)(&MasterIrp->Size + 1), MasterIrp->MdlAddress));
                        status->IoStatus.Status = 0;
                        status->IoStatus.Information = 12i64;
                    }
                }
                else
                {
                    status->IoStatus.Status = 0xC000000D;
                }
                break;
            case 0x80002040:
                if (Options == 48)
                {
                    v33 = MmMapIoSpace_sub((PHYSICAL_ADDRESS *)MasterIrp);
                    status->IoStatus.Status = v33;
                    if (v33 < 0)
                        status->IoStatus.Status = 0xC000009A;
                    else
                        status->IoStatus.Information = 48i64;
                }
                else
                {
                    status->IoStatus.Status = 0xC000000D;
                }
                break;
            case 0x80002044:
                if (Options == 48)
                {
                    MdlAddress = MasterIrp->MdlAddress;
                    if (MdlAddress)
                    {
                        MmUnmapIoSpace(MdlAddress, MasterIrp->Flags);
                        if (HIDWORD(MasterIrp->ThreadListEntry.Blink) < 0x100)
                        {
                            Blink_high = HIDWORD(MasterIrp->ThreadListEntry.Blink);
                            if (*(PMDL *)(8 * Blink_high - 0x7FCB2DF0000i64 + 17264) == MasterIrp->MdlAddress && *(_DWORD *)(4 * Blink_high - 0x7FCB2DF0000i64 + 19312) == MasterIrp->Flags)
                            {
                                *(_QWORD *)(8 * Blink_high - 0x7FCB2DF0000i64 + 17264) = 0i64;
                                *(_DWORD *)(4 * Blink_high - 0x7FCB2DF0000i64 + 19312) = 0;
                            }
                        }
                        status->IoStatus.Status = 0;
                    }
                    else
                    {
                        status->IoStatus.Status = 0xC000000D;
                    }
                }
                else
                {
                    status->IoStatus.Status = 0xC000000D;
                }
                break;
            case 0x80002048:
                if (Options == 48)
                {
                    v25 = MasterIrp->MdlAddress;
                    if (v25 && HIDWORD(MasterIrp->ThreadListEntry.Blink) < 0x100 && (v26 = HIDWORD(MasterIrp->ThreadListEntry.Blink), *(PMDL *)(8 * v26 - 0x7FCB2DF0000i64 + 17264) == v25) && (IrpCount = MasterIrp->AssociatedIrp.IrpCount, v28 = *(&MasterIrp->Flags + 1), *(_DWORD *)(4 * v26 - 0x7FCB2DF0000i64 + 19312) >= (unsigned int)(v28 + IrpCount)))
                    {
                        v29 = IrpCount - 1;
                        if (v29)
                        {
                            v30 = v29 - 1;
                            if (v30)
                            {
                                if (v30 == 2)
                                    HIDWORD(MasterIrp->AssociatedIrp.SystemBuffer) = *(_DWORD *)((char *)&v25->Next + v28);
                            }
                            else
                            {
                                HIDWORD(MasterIrp->AssociatedIrp.SystemBuffer) = *(unsigned __int16 *)((char *)&v25->Next + v28);
                            }
                        }
                        else
                        {
                            HIDWORD(MasterIrp->AssociatedIrp.SystemBuffer) = *((unsigned __int8 *)&v25->Next + v28);
                        }
                        status->IoStatus.Status = 0;
                        status->IoStatus.Information = 48i64;
                    }
                    else
                    {
                        status->IoStatus.Status = 0xC000000D;
                    }
                }
                else
                {
                    status->IoStatus.Status = 0xC000000D;
                }
                break;
            case 0x8000204C:
                if (Options == 48)
                {
                    v19 = MasterIrp->MdlAddress;
                    if (v19 && HIDWORD(MasterIrp->ThreadListEntry.Blink) < 0x100 && (v20 = HIDWORD(MasterIrp->ThreadListEntry.Blink), *(PMDL *)(8 * v20 - 0x7FCB2DF0000i64 + 17264) == v19) && (v21 = MasterIrp->AssociatedIrp.IrpCount, v22 = *(&MasterIrp->Flags + 1), *(_DWORD *)(4 * v20 - 0x7FCB2DF0000i64 + 19312) >= (unsigned int)(v22 + v21)))
                    {
                        v23 = v21 - 1;
                        if (v23)
                        {
                            v24 = v23 - 1;
                            if (v24)
                            {
                                if (v24 == 2)
                                    *(_DWORD *)((char *)&v19->Next + v22) = HIDWORD(MasterIrp->AssociatedIrp.SystemBuffer);
                            }
                            else
                            {
                                *(_WORD *)((char *)&v19->Next + v22) = WORD2(MasterIrp->AssociatedIrp.SystemBuffer);
                            }
                        }
                        else
                        {
                            *((_BYTE *)&v19->Next + v22) = BYTE4(MasterIrp->AssociatedIrp.SystemBuffer);
                        }
                        status->IoStatus.Status = 0;
                        status->IoStatus.Information = 0x30i64;
                    }
                    else
                    {
                        status->IoStatus.Status = 0xC000009A;
                    }
                }
                else
                {
                    status->IoStatus.Status = 0xC000000D;
                }
                break;
            case 0x80002050:
                if (Options == 24)
                {
                    Flags = MasterIrp->Flags;
                    if (Flags && Flags <= 4)
                    {
                        HalGetBusDataByOffset(
                            PCIConfiguration,
                            *(_DWORD *)&MasterIrp->Type,
                            *(_DWORD *)(&MasterIrp->Size + 1) & 0x1F | (32 * ((__int64)MasterIrp->MdlAddress & 7)),
                            &MasterIrp->Flags + 1,
                            HIDWORD(MasterIrp->MdlAddress),
                            Flags);
                        status->IoStatus.Status = 0;
                        status->IoStatus.Information = 0x18i64;
                    }
                    else
                    {
                        status->IoStatus.Status = 0xC000000D;
                    }
                }
                else
                {
                    status->IoStatus.Status = 0xC000000D;
                }
                break;
            case 0x80002054:
                if (Options == 24)
                {
                    Length = MasterIrp->Flags;
                    if (Length && Length <= 4)
                    {
                        Offset = HIDWORD(MasterIrp->MdlAddress);
                        if (Offset < 0x10 || Offset > 0x27)
                        {
                            HalSetBusDataByOffset(
                                PCIConfiguration,
                                *(_DWORD *)&MasterIrp->Type,
                                *(_DWORD *)(&MasterIrp->Size + 1) & 0x1F | (32 * ((__int64)MasterIrp->MdlAddress & 7)),
                                &MasterIrp->Flags + 1,
                                Offset,
                                Length);
                            status->IoStatus.Status = 0;
                            status->IoStatus.Information = 24i64;
                        }
                        else
                        {
                            status->IoStatus.Status = 0xC000000D;
                        }
                    }
                    else
                    {
                        status->IoStatus.Status = 0xC000000D;
                    }
                }
                else
                {
                    status->IoStatus.Status = 0xC000000D;
                }
                break;
            default:
                goto LABEL_65;
            }
        }
        else
        {
            switch (IOCTL_Code)
            {
            case 0x8000202C:
                if (Options == 8)
                {
                    v15 = dword_FFFFF8034D214360;
                    if (*(_DWORD *)&MasterIrp->Type != 0x80000000)
                        v15 = *(_DWORD *)&MasterIrp->Type;
                    dword_FFFFF8034D214360 = *(_DWORD *)(&MasterIrp->Size + 1) + v15;
                    *(_DWORD *)&MasterIrp->Type = dword_FFFFF8034D214360;
                    status->IoStatus.Status = 0;
                    status->IoStatus.Information = 8i64;
                }
                else
                {
                    status->IoStatus.Status = 0xC000000D;
                }
                break;
            case 0x80002000:
                v14 = sub_FFFFF8034D211150(a1, (PHYSICAL_ADDRESS *)MasterIrp, Options, v6);
                status->IoStatus.Status = v14;
                if (v14 < 0)
                    status->IoStatus.Status = 0xC000000D;
                else
                    status->IoStatus.Information = 8i64;
                break;
            case 0x80002004:
                if (Options < 8)
                    status->IoStatus.Status = 0xC0000001;
                else
                    status->IoStatus.Status = ZwUnmapViewOfSection((HANDLE)0xFFFFFFFFFFFFFFFFi64, *(PVOID *)&MasterIrp->Type);
                break;
            case 0x80002008:
                if (Options == 8)
                {
                    v13 = __inbyte(MasterIrp->Type);
                    *(_DWORD *)(&MasterIrp->Size + 1) = v13;
                    status->IoStatus.Status = 0;
                    status->IoStatus.Information = 8i64;
                }
                else
                {
                    status->IoStatus.Status = 0xC000000D;
                }
                break;
            case 0x8000200C:
                if (Options == 8)
                {
                    v12 = __inword(MasterIrp->Type);
                    *(_DWORD *)(&MasterIrp->Size + 1) = v12;
                    status->IoStatus.Status = 0;
                    status->IoStatus.Information = 8i64;
                }
                else
                {
                    status->IoStatus.Status = 0xC000000D;
                }
                break;
            case 0x80002010:
                if (Options == 8)
                {
                    v11 = __indword(MasterIrp->Type);
                    *(_DWORD *)(&MasterIrp->Size + 1) = v11;
                    status->IoStatus.Status = 0;
                    status->IoStatus.Information = 8i64;
                }
                else
                {
                    status->IoStatus.Status = 0xC000000D;
                }
                break;
            case 0x80002014:
                if (Options == 8)
                {
                    if (*(_DWORD *)&MasterIrp->Type == 3324 && (v10 = __indword(0xCF8u), v10 < 0) && (v10 & 0xFCu) - 16 <= 0x17)
                    {
                        status->IoStatus.Status = 0xC000000D;
                    }
                    else
                    {
                        __outbyte(MasterIrp->Type, *((_BYTE *)&MasterIrp->Size + 2));
                        status->IoStatus.Status = 0;
                        status->IoStatus.Information = 8i64;
                    }
                }
                else
                {
                    status->IoStatus.Status = 0xC000000D;
                }
                break;
            case 0x80002018:
                if (Options == 8)
                {
                    if (*(_DWORD *)&MasterIrp->Type == 3324 && (v9 = __indword(0xCF8u), v9 < 0) && (v9 & 0xFCu) - 16 <= 0x17)
                    {
                        status->IoStatus.Status = 0xC000000D;
                    }
                    else
                    {
                        __outword(MasterIrp->Type, *(&MasterIrp->Size + 1));
                        status->IoStatus.Status = 0;
                        status->IoStatus.Information = 8i64;
                    }
                }
                else
                {
                    status->IoStatus.Status = 0xC000000D;
                }
                break;
            case 0x8000201C:
                if (Options == 8)
                {
                    if (*(_DWORD *)&MasterIrp->Type == 3324 && (v8 = __indword(0xCF8u), v8 < 0) && (v8 & 0xFCu) - 16 <= 0x17)
                    {
                        status->IoStatus.Status = 0xC000000D;
                    }
                    else
                    {
                        __outdword(MasterIrp->Type, *(_DWORD *)(&MasterIrp->Size + 1));
                        status->IoStatus.Status = 0;
                        status->IoStatus.Information = 8i64;
                    }
                }
                else
                {
                    status->IoStatus.Status = 0xC000000D;
                }
                break;
            case 0x80002028:
                if (Options == 8)
                {
                    *(_DWORD *)&MasterIrp->Type = 1;
                    *(_DWORD *)(&MasterIrp->Size + 1) = 8;
                    status->IoStatus.Status = 0;
                    status->IoStatus.Information = 8i64;
                }
                else
                {
                    status->IoStatus.Status = 0xC000000D;
                }
                break;
            default:
            LABEL_65:
                status->IoStatus.Status = 0xC000000D;
                break;
            }
        }
    }
    // EXIT
    // return NT STATUS
    v36 = status->IoStatus.Status;
    IofCompleteRequest(status, 0);
    return v36;
}